// Based on the Lezer JavaScript grammer
// <https://github.com/lezer-parser/javascript/blob/main/src/javascript.grammar>

@skip { spaces | LineComment }

@precedence {
  member,
  access,
  call,
  prefix,
  postfix,
  typeof,
  exp @right,
  times @left,
  plus @left,
  shift @left,
  loop,
  rel @left
}


@top Program { statement* }

statement[@isGroup=Statement] {
  ShowStatement { ShowOrHidden expression StyleMapping? } |
  LetStatement { kw<"let"> Identifier "=" expression StyleMapping? } |
  FunctionDefinition { kw<"let"> CallExpression "=" expression StyleMapping? } |
  RegressionStatement { kw<"regression"> expression "~" expression StyleMapping? } |
  Table |
  Image { kw<"image"> String String StyleMapping? } |
  Text { String StyleMapping? } |
  Folder { kw<"folder"> String FolderInner StyleMapping? } |
  Settings { kw<"settings"> StyleMapping }
}

FolderInner {
  "{" statement* "}"
}

Table {
  kw<"table"> TableInner StyleMapping?
}

TableInner {
  "{" TableColumn* "}"
}

TableColumn {
  ShowOrHidden
  (AssignmentStart { Identifier "=" })?
  expression
  StyleMapping?
}

ShowOrHidden { kw<"show"> | kw<"calc"> }

expression[@isGroup=Expression] {
  Number |
  Identifier |
  String |
  RepeatedExpression |
  ListExpression |
  ListComprehension { "[" expression kw<"for"> commaSep1<AssignmentExpression> "]" } |
  Piecewise { "{" commaSep<PiecewiseBranch> "}" } |
  PrefixExpression { !prefix ArithOp<"-"> expression } |
  // ParenthesizedExpression also includes tuples (points)
  ParenthesizedExpression { "(" commaSep1<expression> ")" } |
  MemberExpression { expression !member "." Identifier } |
  ListAccessExpression { expression !access ListExpression } |
  BinaryExpression |
  PostfixExpression { expression !postfix ArithOp<"!"> } |
  CallExpression |
  StyleMapping
}

PiecewiseBranch { expression ":" expression }

AssignmentExpression { Identifier "=" expression }

CallExpression { expression !call "(" commaSep<expression> ")" }

StyleMapping {
  MappingStart commaSep<MappingEntry> MappingEnd
}

MappingEntry { Identifier ":" expression }

RepeatedExpression {
  (kw<"integral"> | kw<"sum"> | kw<"product">)
  Identifier "=" "(" expression "..." expression ")"
  expression
}

ListExpression {
  "[" commaSep<expression> ("..." ","? commaSep<expression>)? "]"
}

BinaryExpression {
  expression !exp ArithOp<"^"> expression |
  expression !times (divide | ArithOp<"*">) expression |
  expression !plus ArithOp<"+" | "-"> expression |
  expression !rel CompareOp<"<" "="? | ">" "="? | "=="> expression
}

commaSep<content> {
  "" | content ("," content)* ","?
}

commaSep1<content> {
  content ("," content)* ","?
}

ArithOp<expr> { expr }
CompareOp<expr> { expr }

// Keywords
kw<term> { @specialize[@name={term}]<Identifier, term> }

@tokens {
  Identifier { $[a-zA-Z] $[a-zA-Z0-9]* }

  String { '"' (!["\\] | "\\" _)* '"' }

  Number {
    std.digit+ ("." (std.digit)+)? |
    "." std.digit+
  }

  LineComment { "//" ![\n]* }

  divide[@name=ArithOp] { "/" }

  @precedence { LineComment, divide }

  spaces { $[ \t\n\r]+ }

  MappingStart[closedBy=MappingEnd] { "@{" }
  MappingEnd[openedBy=MappingStart] { "}" }


  "(" ")" "[" "]" "{" "}"

  "..." "," "=" ":" "."
}

@detectDelim
